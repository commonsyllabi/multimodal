"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _electron = require("electron");

var _electron2 = _interopRequireDefault(_electron);

var _child_process = require("child_process");

var _child_process2 = _interopRequireDefault(_child_process);

var _path = require("path");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ElectronPlugin = function () {
	function ElectronPlugin(options) {
		_classCallCheck(this, ElectronPlugin);

		this.hashIndex = {};
		this.options = options || {};

		if (!this.options.test || !(this.options.test instanceof RegExp)) {
			throw new Error("webpack-electron-plugin: test is required, and must be a RegExp");
		}

		if (!this.options.path || typeof this.options.path !== "string") {
			throw new Error("webpack-electron-plugin: path is required, and must be a string");
		}

		this.options.path = (0, _path.resolve)(this.options.path);

		// defaults
		this.options.args = this.options.args || [];
		this.options.options = this.options.options || {};
		this.options.options.stdio = this.options.options.stdio || "inherit";
	}

	_createClass(ElectronPlugin, [{
		key: "launch",
		value: function launch() {
			// if electron is open, kill it
			if (this.child) {
				this.child.kill();
				this.child = null;
			}

			this.child = _child_process2.default.spawn(_electron2.default, this.options.args.concat(this.options.path), this.options.options);
		}
	}, {
		key: "apply",
		value: function apply(compiler) {
			var _this = this;

			// when compilation is done
			compiler.plugin("done", function (stats) {
				var shouldRelaunch = false;
				stats.compilation.modules.forEach(function (module) {
					if (!module.resource) return true;
					if (!module._cachedSource) return true;

					// get hash
					var hash = module._cachedSource.hash;
					var split = module.id.split("!");
					// get last path in module id
					var id = split[split.length - 1];
					// if matches regex and hash is different
					if (id.match(_this.options.test) && _this.hashIndex[module.resource] !== hash) {
						shouldRelaunch = true;
					}

					// update hash in index
					_this.hashIndex[module.resource] = hash;
				});

				if (shouldRelaunch) _this.launch();
			});
		}
	}]);

	return ElectronPlugin;
}();

exports.default = ElectronPlugin;
module.exports = exports["default"];